  # 열순서변경 
DT1 <- DT1[ ,c(6,7,1,2,3,4,8,5)] 

#  해당하는 것 추출  
n_date <- unique(energy_3[, date])
#training data <- 3주치 data(504개)
data_train <- energy_3[date %in% n_date1[7:27]]


#  특정 열을 찾아서 이름을 변경하는 방법

 names(ac)[names(ac)=="Time"] <- c("newTime")

 names(ac)

[1] "newTime" "Power"  

출처: http://goodtogreate.tistory.com/entry/데이터구조 [GOOD to GREAT]

#paste
paste("Everybody", "loves", "stats.", sep="-")

#저장
fwrite(energy_2, "final1.csv")


##ggplot 분할
# gridExtra 패키지 안에 있는 grid.arrage() 함수를 이용하여 화면 분할
library(gridExtra)

p1 = ggplot(diamonds, aes(x=cut, y=price)) + geom_bar()
p2 = ggplot(diamonds, aes(x=color, y=price)) + geom_bar()

 
# 1행 2열로 화면 분할함
grid.arrange(p1, p2, ncol=2)

# y축 직선 긋기
ggplot(the.data, aes( year, value ) ) +  
    geom_hline(yintercept = 50) 
    
    
#시계열 data변환 
#주기 2개- 한시간 단위 측정일 경우 하루24, 일주일168(24*7)
ts.train<-msts(data_train$hour_ave, seasonal.periods=c(48,336))
#주기 1개
data_ts <- ts(data_train$value, freq = period)

#rep
#각각 두번씩
rep(1:5, each=2)
 1 1 2 2 3 3 4 4 5 5
#두번 반복
rep(1:5, 2)
 1 2 3 4 5 1 2 3 4 5
rep(c("Real", "RPART"), each = length(matrix_train$Load))

#seq
#시작/끝/by간격, length.out-시작과 끝을 몇개로 나누는지

> seq(1,10, by=2)
[1] 1 3 5 7 9
> seq(1,10, length.out=3)
[1]  1.0  5.5 10.0

#apply(x,margin,func, ...)

• x: array
• margin: subscripts, for matrix, 1 for row, 2 for column
• func: the function

> apply(BOD,2,sum)



#expand.grid
#expand.grid() function creates a data frame from all combinations of the supplied vectors or factors.
subtype <- c("green","red","yellow")
sex <- c("M","F")
expand.grid(subtype, sex)


> subtype <- c("green","red","yellow")
> sex <- c("M","F")
> expand.grid(subtype, sex)
Var1 Var2
1  green    M
2    red    M
3 yellow    M
4  green    F
5    red    F
6 yellow    F

